* Yarr : Renderer
It's about time we start building our RSS reader.

Now we're not going to use any JS frameworks for writing our app, but that doesn't mean we can't take "inspiration" from frameworks. Other than using virtual-dom, one awesome idea React has made obvious is writing UI in terms of components. Isolation is the key to reuseability, scalability, maintainability, and god-knows-what-bilities. We'll try to build our UI in terms of isolated components.

Using virtual DOM makes it pretty natural actually. Virtual-DOM has these requirements:

- It needs a complete view every time we have to make any update in DOM
- The whole of our virtual-dom must have a single parent, one `rootNode`. It must have a container element on top of the markup tree. If you know React this will be recognisable.

Now let's forget all the component bullshit for a moment and try to make our counter from the last step more elegant. Here's the code from last step:

#+begin_src javascript
import {Observable} from 'rx';

import {h} from 'virtual-dom';
import createElement from 'virtual-dom/create-element';
import diff from 'virtual-dom/diff';
import patch from 'virtual-dom/patch';


let render = (count) => <h1 className='hello-world'>Hello World {count + ''}</h1>;

let view = render(0);
let rootNode = createElement(view);
document.body.appendChild(rootNode);

Observable
  .interval(1000)
  .map(n => render(n + 1))
  .subscribe(
    newView => {
      let patches = diff(view, newView);
      rootNode = patch(rootNode, patches);
      view = newView;
    }
  );
#+end_src

- *Be more classy*

We are rendering our vDOM under `document.body`. Let's be little more classy and create a dedicated dumping ground in our html. Make ~<body>~ in `index.html` look like this:

#+begin_src xml
<body class="home-template">
  <span id="app"></span> <!-- new code -->

  <script src="dist/app.js"></script>
</body>
#+end_src

Now we can use ~span#app~ for rendering the output. It's not really a hard requirement to do it this way and we can get away with putting our vDOM output in document.body too.

#+begin_src javascript
.
.
.
let rootNode = createElement(view);

let baseDOMNode = document.getElementById('app');
baseDOMNode.appendChild(rootNode);

Observable
.
.
.
#+end_src

- *Divide views in Components*

If we look at our code now, ~render~ method provide us our *complete view* as hyperscript, and ~count~ is our state. I think that's a dead give-away for how we can approach having isolated components.

Let's divide our view into two components: greeting and counter. Create ~/src/components~ directory, and create two files ~components/greeting.js~ and ~components/counter.js~.

#+begin_src javascript
//components/greeting.js
import h from 'virtual-dom/h';

let render = () => <h1>Hello World</h1>

export default render;
#+end_src

#+begin_src javascript
//components/counter.js
import h from 'virtual-dom/h';

let render = (count) => <h1>{count}</h1>;

export default render;
#+end_src

~export default XXX~ is an ES6 construct which gives the XXX value to the importer of the module with whatever name importer want it to be. So we can do ~import greeting from "./components/greeting";~ and get the `render` method from `components/greeting` module as `greeting`.

Let's change our `index.js` file to use our new components:

#+begin_src javascript
//index.js

import {Observable} from 'rx';

import {h} from 'virtual-dom';
import createElement from 'virtual-dom/create-element';
import diff from 'virtual-dom/diff';
import patch from 'virtual-dom/patch';

import greeting from './components/greeting';
import counter from './components/counter';

let render = (count) => {
  count += '';
  return <div className="container">
    {greeting()}
    {counter(count)}
  </div>;
}

let view = render(0);
let rootNode = createElement(view);

let baseDOMNode = document.getElementById('app');
baseDOMNode.appendChild(rootNode);

Observable
  .interval(1000) //replace the steTimeout and `count` state variable. Interval will give us an incrementing number every 1000 milliseconds
  .map(n => render(n + 1))
  .subscribe(
    newView => {
      let patches = diff(view, newView);
      rootNode = patch(rootNode, patches);
      view = newView;
    }
  );
#+end_src

- *Mother of all Components*

We had to change our render method to have a container HTML tag (requirement #2 of vDOM, remember?). So we need to have a container, hmmm. Why not create something like a root or main component, which imports all components and provide a single markup tree? Let's just do it. Create ~components/main.js~:

#+begin_src javascript
//components/main.js

import h from 'virtual-dom/h';

import greeting from './greeting';
import counter from './counter';

let render = (count) => {
  count += '';
  return <div className="container">
    {greeting()}
    {counter(count)}
  </div>;
}

export default render;
#+end_src

Our ~index.js~ looks somewhat like this now:

#+begin_src javascript
import {Observable} from 'rx';

import {h} from 'virtual-dom';
import createElement from 'virtual-dom/create-element';
import diff from 'virtual-dom/diff';
import patch from 'virtual-dom/patch';

import mainView from './components/main';

let view = mainView(0);
let rootNode = createElement(view);

let baseDOMNode = document.getElementById('app');
baseDOMNode.appendChild(rootNode);

Observable
  .interval(1000) //replace the steTimeout and `count` state variable. Interval will give us an incrementing number every 1000 milliseconds
  .map(n => mainView(n + 1))
  .subscribe(
    newView => {
      let patches = diff(view, newView);
      rootNode = patch(rootNode, patches);
      view = newView;
    }
  );
#+end_src

- *Separation of concerns* and *Propagation of change*

Now this is called separation of concerns. Or is it? We are passing ~count~ to ~newView~, `count` however, is something which should be internal to `counter` component, outer views don't need to know about it.
But if we move `count` inside the `counter` component, how will it tell the main view that it needs to be updated? And how will the main view tell our index.js that it should be re-rendered? This propagation of change can be major pain in the ass /cough/ $digest loop /cough/

What are we using RxJS for? Among many things, Observable are reactive. They can push data to their user/owner/whatever. We can make a `counter` component return an Observable of hyperscript (the HTMLish syntax) instead of just returning a single hyperscript value. Let's change the `counter` component and make it take care of its internal state.

#+begin_src javascript
//components/counter.js
import {Observable} from 'rx';
import h from 'virtual-dom/h';

let render_ = () => Observable
      .interval(1000)
      .map(count => count.toString())
      .map(count => <span>{count}</span>);

export default render_;

#+end_src

We need to change our ~components/main.js~ to use `counter_` as an Observable. Now to get a value out of an Observable, we have to subscribe to it (or operate on it). We don't want to subscribe to our counter_ observable right now (because that will end the chain, remember? ~Observable.prototype.subscribe~ is where it all ends). We want to pass this along to our ~index.js~ file which will finally subscribe to it and render it to our page. So we need to convert our main view to an Observable too, which will use the `counter_` Observable, and return an Observable of the complete view.

#+begin_src javascript
//components/main.js
import h from 'virtual-dom/h';

import greeting from './greeting';
import counter_ from './counter';

let view = (counterView) => {
  return <div className="container">
    {greeting()}
    {counterView}
  </div>;
}

let render_ = () => counter_()
      .map(view);

export default render_;
#+end_src

And finally, we need to change our index.js to make use of our mainView_.

#+begin_src javascript
import {Observable} from 'rx';

import {h} from 'virtual-dom';
import createElement from 'virtual-dom/create-element';
import diff from 'virtual-dom/diff';
import patch from 'virtual-dom/patch';

import mainView_ from './components/main';

let view = null;
let rootNode = null;

mainView_()
  .subscribe(
    newView => {
      if (!view) {
        view = newView;
        rootNode = createElement(view);
        let baseDOMNode = document.getElementById('app');
        return baseDOMNode.appendChild(rootNode);
      }

      let patches = diff(view, newView);
      rootNode = patch(rootNode, patches);
      view = newView;
    }
  );
#+end_src

- *Observable.prototype.startWith*?

If we look at our app now you will think it isn't working as it starts blank and then it renders everything and counter starts. Why's that? It should render immediately. Is it a performance problem?

Hell no. Let's find the issue. Take look at our chain of Observable, where do it start? In the `counter` component, remember? `counter` uses ~Observable.interval~ as its source, so may be that's what holds the rendering for that one initial second. Let's experiment, and change the interval to `5000` and see if that increases the rendering delay. It does!

Pheww, we caught the issue at least. We want our Observable to start immediately, with a default. Remember the Rx operator for this? ~startWith~. Let's change our `counter` component to use `startWith`:

#+begin_src javascript
import {Observable} from 'rx';
import h from 'virtual-dom/h';

let render_ = () => Observable
      .interval(1000)
      .map(n => n+1)
      .startWith(0)
      .map(count => count.toString())
      .map(count => <span>{count}</span>);

export default render_;
#+end_src

That solved our initial delay in rendering. Yay! Notice we added ~map(n => n+1)~, that's because we already provided `0` manually.

The takeaway from this issue is that if we ever see nothing rendering on the screen, or the whole view rendering a little late, it's very likely an Observable is in need of a `startWith` default value.

- *Consistent System = Maintainable System*

  Notice each of our components return a function. Why's that? It's so we can pass the initial state to our component if it needs any. But even though our components don't need initial state, they're still returning a function. Well, that's to keep our system consistent. Consistency is key to maintainability.

  Consistency reminds us, what a bunch of hypocrites we are! Our components return a function which returns an Observable of views (hyperscript), but look at the `greeting` component. It doesn't!! Ok We shall respect the moral code and make it consistent. Let's convert it to return an Observable instead.

  #+begin_src javascript
  //components/greeting.js
  import h from 'virtual-dom/h';
  import {Observable} from 'rx';

  let render_ = () => Observable.return(<h1>Hello World</h1>);

  export default render_;
  #+end_src

  ~Observable.return~ creates an Observable which only returns one value that we pass it. Now we need to modify `components/main.js` too.

  #+begin_src javascript
    import h from 'virtual-dom/h';
    import {Observable} from 'rx';

    import greeting_ from './greeting';
    import counter_ from './counter';

    let view = (counterView, greetingView) => {
      return
      <div className="container">
        {greetingView}
        {counterView}
      </div>;
    }

    let render_ = () => Observable
          .combineLatest(
            counter_(),
            greeting_(),
            view
          );

    export default render_;
  #+end_src

  Remember the ~Observable.combineLatest~? I hope you do.

  We need to recreate the whole view on every change, so we need to combine all the parts (i.e components) every time we need to update something in the DOM. That's what the `view` method in `main.js` does (combines the components). ~Observable.combineLatest~ will run the ~view~ function every time any of the participant Observable (counter_ and greeting_) emit a new value. 

  ~combineLatest~ will make sure it combines the latest emitted value from Observable. So we get caching (or memoizing) for free! The only condition is that each of the participant Observable must emit at least once (for that we'll use `Observable.startWith` whenever required).

  So, we have a way to make isolated, consistent components! I think it's not bad for a system with such little amount of layers of abstraction.

- *Clean up index.js*

  Let's clean up the index.js to turn our vDOM rendering to be more re-useable. Turn the *Renderer* to a class perhaps? Or a closure maybe?

  #+begin_src javascript
  //index.js
  import {Observable} from 'rx';

  import {h} from 'virtual-dom';
  import createElement from 'virtual-dom/create-element';
  import diff from 'virtual-dom/diff';
  import patch from 'virtual-dom/patch';

  import mainView_ from './components/main';

  let baseDOMNode = document.getElementById('app');

  let render = (mainView_, baseDOMNode) => {
    let view = null;
    let rootNode = null;

    let initialize = (newView) => {
      view = newView;
      rootNode = createElement(view);
      baseDOMNode.appendChild(rootNode);
    };

    let update = (newView) => {
      let patches = diff(view, newView);
      rootNode = patch(rootNode, patches);
      view = newView;
    };

    return mainView_
      .subscribe(
        newView => view
          ? update(newView)
          : initialize(newView),
        error => console.warn('Error occured somewhere along Observable chain', error)
      );
  };

  let view_ = mainView_();
  render(view_, baseDOMNode);
  #+end_src

  Let's separate the concerns even further and move vDOM renderer to its own file. We wanna keep our index.js file as clean as we can. Create a file ~src/renderer.js~:

  #+begin_src javascript
  //renderer.js
  import {h} from 'virtual-dom';
  import createElement from 'virtual-dom/create-element';
  import diff from 'virtual-dom/diff';
  import patch from 'virtual-dom/patch';


  let render = (mainView_, baseDOMNode) => {
    let view = null;
    let rootNode = null;

    let initialize = (newView) => {
      view = newView;
      rootNode = createElement(view);
      baseDOMNode.appendChild(rootNode);
    };

    let update = (newView) => {
      let patches = diff(view, newView);
      rootNode = patch(rootNode, patches);
      view = newView;
    };

    return mainView_
      .subscribe(
        newView => view
          ? update(newView)
          : initialize(newView),
        error => console.warn('Error occured somewhere along Observable chain', error)
      );
  };

  export default render;
  #+end_src

  And then we can change our `index.js` to this:

  #+begin_src javascript
  //index.js
  import mainView_ from './components/main';
  import render from './renderer';

  let view_ = mainView_();

  render(view_, document.getElementById('app'));
  #+end_src

  Now that's what we call a clean main file ^_^

  I hope you've not gotten to lost an confused! 
  If you've got this far give yourself on the back, you made it through the toughest part of this tutorial. Everything will be a breeze from here on, I promise.

Now that we have a somewhat saner way to write good (consistent, isolated components), we can move onto another important aspect of a web-app: Events.

#+begin_src bash
git checkout 4-delegated-events
#+end_src
